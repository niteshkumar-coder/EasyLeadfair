
import { GoogleGenAI, Type } from "@google/genai";
import { BusinessLead, SearchQuery } from "../types";

/**
 * Enhanced Lead Finder using Gemini 3 Pro with Grounded Search.
 * Focuses on accuracy and preventing hallucinations in contact details.
 */
export async function findBusinessLeads(
  query: SearchQuery,
  userLocation?: { lat: number; lng: number }
): Promise<BusinessLead[]> {
  const apiKey = process.env.API_KEY;
  
  if (!apiKey || apiKey === "undefined" || apiKey === "") {
    throw new Error("API_KEY_MISSING: Please ensure your Gemini API Key is correctly configured.");
  }

  const ai = new GoogleGenAI({ apiKey });
  const { city, categories, radius } = query;

  const categoriesStr = categories.join(', ');
  
  // System instruction is critical to enforce the "No Fake Data" rule
  const systemInstruction = `You are a high-accuracy Lead Intelligence Specialist.
Your task is to find businesses in "${city}, India" for the category "${categoriesStr}".

ACCURACY PROTOCOL:
1. SEARCH: You MUST use the googleSearch tool for every business to verify its details.
2. PHONE NUMBER: Look for the "Google Business Profile" of each shop. Extract the EXACT "formatted_phone_number". 
3. NULL POLICY: If the phone number is not explicitly listed on their Google profile, return null. NEVER provide a placeholder or random number.
4. VALIDATION: Ensure the business is active and located within or near ${city}.
5. OUTPUT: Provide exactly what you find on the live web. Do not guess.`;

  const prompt = `Search for 20 verified business leads in "${city}" for categories: "${categoriesStr}".
For each lead, verify their contact details using Google Search.
Capture:
- Business Name
- Official Phone Number (exactly as on Google Maps profile, else null)
- Website (verified official URL, else null)
- Email (only if found on their site/profile, else null)
- Rating and total reviews
- Physical Address
- Latitude/Longitude

Return a JSON array of objects.`;

  try {
    const response = await ai.models.generateContent({
      model: "gemini-3-pro-preview",
      contents: prompt,
      config: {
        systemInstruction,
        tools: [{ googleSearch: {} }],
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              name: { type: Type.STRING },
              address: { type: Type.STRING },
              formatted_phone_number: { 
                type: Type.STRING, 
                nullable: true,
                description: "Official phone number from the Google Maps profile."
              },
              email: { type: Type.STRING, nullable: true },
              website: { type: Type.STRING, nullable: true },
              maps_url: { type: Type.STRING, nullable: true },
              lat: { type: Type.NUMBER },
              lng: { type: Type.NUMBER },
              rating: { type: Type.NUMBER, nullable: true },
              userRatingsTotal: { type: Type.INTEGER, nullable: true }
            },
            required: ["name", "address", "lat", "lng"]
          }
        }
      }
    });

    const text = response.text || "";
    // Robust JSON extraction in case the model returns extra text
    const jsonMatch = text.match(/\[[\s\S]*\]/);
    const cleanedJson = jsonMatch ? jsonMatch[0] : text;

    let results = JSON.parse(cleanedJson);
    if (!Array.isArray(results)) {
      if (typeof results === 'object' && results !== null) {
        results = [results];
      } else {
        return [];
      }
    }

    return results.map((item: any, index: number) => {
      const name = item.name || "Unknown Business";
      const address = item.address || "Address not found";
      
      // Secondary check to filter out obviously fake phone numbers generated by AI
      let phone = item.formatted_phone_number ? String(item.formatted_phone_number).trim() : null;
      if (phone) {
        const digitsOnly = phone.replace(/[^0-9]/g, '');
        // Block common hallucinated patterns (e.g., 1234567890, 0000000000, 9999999999)
        if (
          digitsOnly.length < 8 || 
          /^(.)\1+$/.test(digitsOnly) || 
          digitsOnly === '1234567890' ||
          phone.toLowerCase().includes('not available')
        ) {
          phone = null;
        }
      }

      return {
        id: `lead-${Date.now()}-${index}`,
        name,
        address,
        phone,
        website: item.website || null,
        email: item.email || null,
        owner: null,
        lat: Number(item.lat) || 0,
        lng: Number(item.lng) || 0,
        distance: null, // Will be calculated in UI component
        source: 'Google Search',
        mapsUrl: item.maps_url || `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(name + ' ' + address)}`,
        lastUpdated: new Date().toISOString().split('T')[0],
        rating: item.rating || null,
        userRatingsTotal: item.userRatingsTotal || null
      };
    });

  } catch (error: any) {
    console.error("Critical Generation Error:", error);
    // If it's a JSON parse error, it means the model output was garbage. 
    // Return empty so the UI shows the 'No Results' state instead of crashing.
    return [];
  }
}

export function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  if (!lat1 || !lon1 || !lat2 || !lon2) return 0;
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * (Math.PI / 180);
  const dLon = (lon2 - lon1) * (Math.PI / 180);
  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + 
            Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * 
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}
